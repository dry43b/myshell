#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <dirent.h>
#include <wait.h>
#include <sys/types.h>
#include <sys/utsname.h>
#include <sys/sysinfo.h>
#include <readline/readline.h> // Require GNU Readline library!
#include <readline/history.h>  // Require GNU Readline library!

#define MAX_INPUT_SIZE 1024
#define MAX_HISTORY_SIZE 100

/* 토큰 구조체 정의 */
typedef struct {
    char** tokens; // 토큰 배열
    int count;     // 토큰 개수
} TokenizedInput;

/* 쉘의 타이틀과 시스템 정보를 출력하는 함수 */
void showSystem()
{    
    /* utsname, sysinfo 구조체를 이용하여 시스템 정보를 얻음 */
    struct utsname system_info;
    struct sysinfo sys;

    if (uname(&system_info) != 0) // system_info 변수 할당
    {
        perror("uname");
    }
    else if (sysinfo(&sys)) // sys 변수 할당
    {
        perror("sysinfo");
    }
    

    /* Generated by patorjk.com*/
    printf("  __                            .__\n");
    printf("_/  |_____________         _____|  |__  \tOS: %s %s %s\n", 
            system_info.sysname, 
            system_info.release, 
            system_info.machine);
    printf("\\   __\\_  __ \\__  \\       /  ___/  |  \\ \tHost: %s\n", 
            system_info.nodename);
    printf(" |  |  |  | \\// __ \\_     \\___ \\|   Y  \\\tKernel: %s\n", 
            system_info.version);
    printf(" |__|  |__|  (____  / /\\ /____  >___|  /\\\tMemory: %llu MB / %llu MB\n", 
            (unsigned long long)sys.freeram/1024/1024, 
            (unsigned long long)sys.totalram/1024/1024);
    printf("                  \\/  \\/      \\/     \\/\n");
}
/* readline() 입력을 pashing 하는 함수 */
TokenizedInput tokenizeInput(char* input) {
    const char* delimiter = " \t\n"; // 공백, 탭, 개행 문자를 구분자로 사용
    char* token = strtok(input, delimiter);

    /* TokenizedInput 구조체 초기화 */ 
    TokenizedInput result;
    result.tokens = malloc(MAX_INPUT_SIZE * sizeof(char*));
    result.count = 0;

    while (token != NULL) {
        result.tokens[result.count] = strdup(token);
        result.count++;

        token = strtok(NULL, delimiter);
    }

    return result;
}
/* TokenizedInput 구조체 메모리 해제 함수 */
void freeTokenizedInput(TokenizedInput* tokenizedInput) {
    for (int i = 0; i < tokenizedInput->count; ++i) 
    {
        tokenizedInput->tokens[i] = NULL;
        free(tokenizedInput->tokens[i]);
    }
    free(tokenizedInput->tokens);
    tokenizedInput->count = 0;
}

int main() {
    char* input;        // readline()의 입력 변수
    char prompt[100];   // prompt 저장 변수
    int pid, status;    // fork, exec의 pid, status 저장 변수

    /* 사용자의 홈 디렉토리에 .shell_history 파일을 사용하여 history 저장 - GNU Readline library 활용 */
    using_history();
    char* home_dir = getenv("HOME");        // $HOME 환경 변수를 통해 홈 디렉토리 얻기
    if (home_dir != NULL)
    {
        char history_path[MAX_INPUT_SIZE];
        snprintf(history_path, sizeof(history_path), "%s/.myshell_history", home_dir);
        read_history(history_path);
        stifle_history(MAX_HISTORY_SIZE);   // 최대 명령어까지 저장
    }

    /* 본격적인 shell의 시작 */
    showSystem();

    while (1) {
        snprintf(prompt, sizeof(prompt), 
                "%s@tra.sh \033[100m %s $ \033[m\033[90m\033[m ", 
                getenv("USER"), 
                getcwd(NULL, 1024)); // prompt에 현재 유저와 경로와 함께 출력할 문자열 지정
        input = readline(prompt);

        /* 내부 명령어 */

        /* \n 입력시 */
        if (!input) {
            printf("\n");
            break;
        }

        /* exit 입력시 */
        if (!strcmp(input, "exit")) {
            free(input);
            exit(0);
        }

        if (strlen(input) == 0)
            continue;

        add_history(input);
        TokenizedInput tokens = tokenizeInput(input); // 입력된 명령어를 토큰으로 분리하여 저장
        
        /* 토큰 배열을 사용하여 원하는 내부 명령어 수행 */

        /* system 입력 시*/
        if(!strcmp(tokens.tokens[0], "system"))
        {
            showSystem();
        }

        /* cd 입력 시*/
        if(!strcmp(tokens.tokens[0], "cd"))
        {
            if(tokens.tokens[1] == NULL || *tokens.tokens[1] == '~')
            {
                tokens.count++;
                tokens.tokens[1] = getenv("HOME");
            }
        
            if(chdir(tokens.tokens[1]) == -1)
                printf("-shell: cd: %s: No such file or directory\n", tokens.tokens[1]);
        }

        /* echo 입력 시 - 환경 변수가 출력되지 않는 문제 해결 */
        if(!strcmp(tokens.tokens[0], "echo"))
        {
            char *env;
            int count = 0;
            int isNewline = 0;

            /* -n 인자가 있는지 검사 */
            while(tokens.tokens[count] != NULL)
            {
                if(!strcmp(tokens.tokens[count], "-n"))
                    isNewline++;
                count++;
            }
            count--;

            /* ""로 둘려싸였다면 외부 명령어 처리*/
            env = strstr(tokens.tokens[count], "\"");
            if(env != NULL)
            {
                pid = fork();
                if(pid != 0)
                {
                    pid = wait(&status);
                }
                else
                {
                    execvp(tokens.tokens[0], tokens.tokens);
                    exit(0);
                }
                freeTokenizedInput(&tokens);

                free(input);

                continue;
            }

            /* $로 시작한다면 getenv로 출력 */
            env = strstr(tokens.tokens[count], "$");
            if(env == NULL)
                continue;
            env++;

            tokens.tokens[count] = getenv(env);

            pid = fork();
            if(pid != 0)
            {
                pid = wait(&status);
            }
            else
            {
                execvp(tokens.tokens[0], tokens.tokens);
                exit(0);
            }
            
            
            freeTokenizedInput(&tokens);
            free(input);
            continue;
        }

        /* gccQ 입력 시 - 컴파일 후 바로 출력 */
        if(!strcmp(tokens.tokens[0], "gccQ"))
        {
            char str[20] = "gcc ";
            strcat(str, tokens.tokens[1]);

            if(system(str))
            {
                perror("gccQ: fatal error: no input files");
                continue;
            }
            
            system("./a.out");
            remove("a.out");
        }

        /* fork 및 exec으로 외부 명령어 실행 */
        pid = fork();
        if(pid != 0)
        {
            pid = wait(&status);
        }
        else
        {
            execvp(tokens.tokens[0], tokens.tokens);
            exit(0);
        }

        /* 토큰화된 입력의 메모리 해제 */
        freeTokenizedInput(&tokens);

        free(input);
    }

    /* history 파일 저장 */
    if (home_dir != NULL) {
        char history_path[MAX_INPUT_SIZE];
        snprintf(history_path, sizeof(history_path), "%s/.myshell_history", home_dir);
        append_history(history_max_entries, history_path);
    }

    return 0;
}
